        page

seldsk: call savstk
        call swtchi
        ld   a,c
        cp   4
        jr   nc,seld2
        and  3
        inc  a
        ld   b,80h
seld1:  rlc  b
        dec  a
        jr   nz,seld1
        bit  0,e
        jr   nz,seld4
        ld   a,b
        ld   (37e1h),a
        ld   a,0d0h
        ld   (37ech),a
        ld   a,(37ech)
        and  2
        ld   e,a
        ld   hl,8000h
seld11: ld   a,(37ech)
        and  2
        xor  e
        jr   nz,seld4
        dec  hl
        ld   a,h
        or   l
        jr   nz,seld11
seld2:  ld   hl,0
seld3:  jp   swtcho

seld4:  ld   a,b
        ld   (newbin),a
        ld   a,(curdrv)
        ld   hl,trktab
        ld   e,a
        ld   d,0
        add  hl,de
        ld   a,(37edh)
        ld   (hl),a
        ld   a,c
        ld   (newdrv),a
        ld   hl,trktab
        ld   e,a
        ld   d,0
        add  hl,de
        ld   a,(hl)
        ld   (37edh),a
        ld   l,c
        ld   h,0
      4:add  hl,hl
        push hl
        ld   de,pdtab
        add  hl,de
        ld   de,pdrive
        ld   bc,16
        ldir
        pop  hl
        ld   de,dph
        add  hl,de
        jr   seld3

; ** Set new track

settrk: ld   a,c
        ld   (newtrk),a
        ret

; ** Set new sector

setsec: ld   a,c
        ld   (newblk),a
        ret

; ** Set new destination adress

setdma: ld   (destin),bc
        ret

; ** Read logical record

read:   call savstk
        call initio
        jp   reamem

; ** Write logical record

write:  call savstk
        ld   a,c
        ld   (wrtype+1),a
        call initio
        call wrtmem
wrtype: ld   a,0
        cp   1
        ret  nz
        jp   wrtdsk

; ** Translate sector number
;    translates always

sectrn: ex   de,hl
        ld   b,0
        add  hl,bc
        ld   c,(hl)
        ex   de,hl
        ld   h,b
        ld   l,c
        ret

; ** Home diskhead

home:   xor  a
        ld   (newtrk),a
        ret

; Init for correct error report
; call samsec & flush buffer

initio: ex   (sp),hl
        push de
        push bc
        push hl
        ld   hl,exitio
        ex   (sp),hl
        push hl
        xor  a
        ld   (errflg+1),a
        call samsec
        call nz,readsk
        ret

; Common return

exitio: pop  bc
        pop  de
        pop  hl
errflg: ld   a,0
        or   a
        ret

; Check if same physical sector (Y -> Z)
; and set newsec

samsec: call secno             ;calc & set newsec
        ld   a,(cursec)
        cp   c                 ;new sec ?
        ret  nz
        ld   a,(curtrk)
        ld   b,a
        ld   a,(newtrk)
        cp   b                 ;new trk ?
        ret  nz
        ld   a,(cursid)
        ld   b,a
        ld   a,(newsid)
        cp   b                 ;new side ?
        ret  nz
        ld   a,(curdrv)
        ld   b,a
        ld   a,(newdrv)
        cp   b                 ;new drive ?
        ret

; Translate logical -> physical & select side

secno:  ld   hl,newbin
        ld   bc,(newblk)
        res  4,(hl)
        xor  a
        bit  7,c               ; Backside ?
        jr   z,setsid
        set  4,(hl)
        inc  a
setsid: ld   (newsid),a
        ld   a,7fh
        and  c
        ld   c,a
        ld   a,(newpdb)
        rrca
        rrca
        and  3
        inc  a
seclop: dec  a
        jr   z,secno1
        srl  c
        jr   seclop
secno1: ld   a,c
        ld   (newsec),a
        ret

; read record from memory

reamem: call getblk
        jp   move

; write record to memory

wrtmem: call getblk
        ex   de,hl
        call move
        jp   setwrt

; Move logical record

move:   ld   bc,0080h
        ldir
        ret

; set & reset writeflag

setwrt: ld   a,<clrwrt: xor a>
        ld   (wrtflg),a
        ret

; Compute buffer adress

getblk: ld   bc,(newblk)
        ld   a,(curpdb)
        rrca
        rrca
        and  3
        ld   b,a
        inc  b
        xor  a
getbl1: scf
        adc  a,a
        djnz getbl1
        srl  a
        and  c
        ld   l,a
        ld   h,0
      7:add  hl,hl
        ld   bc,secbuf
        add  hl,bc
        ld   de,(destin)
        ret

; Read physical sector from newxxx
; & set curxxx = newxxx

readsk: ld   a,(wrtflg)
        or   a                 ;Unwritten data in mem ?
        call nz,wrtdsk         ;Y -> Flush buffer first

        ld   hl,newpdb
        ld   de,curpdb
        ld   bc,6
        ldir
        ld   a,88h
        ld   de,021ah
        jp   getit

; Write physical sector

wrtdsk: ld   a,0a8h
        ld   de,0a12h
        call getit
        jp   z,clrwrt
        ret

; set density & size

select: ld   a,(curpdb)
        ld   b,a
        ld   hl,37ech
        and  1
        or   0feh
        ld   (hl),a            ;Select density
        ld   (hl),0d0h
        inc  hl
        inc  hl
        ld   a,b
        and  40h
        or   80h
        ld   (hl),a            ;Select size
        ld   a,0d0h
        ld   (37ech),a

; reselect drive

resel:  ld   a,(curbin)
        ld   (37e1h),a
        ret

; Restore drivehead

restor: ld   c,50h
        call isscmd
        ld   c,0

; Issue head moving cmd

isscmd: call resel
        ld   a,(curpdb)
        and  2
        or   c
        ld   (37ech),a
iss1:   call wait
        bit  0,a
        ret  z
        call resel
        jr   iss1

; Perform disk I/O on curdrv, cursid, curtrk, cursec

getit:  ld   (dskcmd),a
        ld   a,(errflg+1)
        or   a
        ret  nz                ;Return if previous err
        ld   b,1ch
        bit  5,a
        jr   z,getit0
        ld   b,7ch
getit0: ld   a,b
        ld   (dskerr),a
        ld   (getit3),de
        call swtchi
        call select
        ld   b,5               ;No of retries
getit1: push bc
        ld   a,(cursec)
        ld   (37eeh),a         ;Set sector
        ld   hl,curpdb
        ld   a,(curtrk)
        bit  5,(hl)            ;Double track ?
        jr   z,getitq
        sla  a
getitq: bit  4,(hl)            ;Double sided ?
        jr   z,getitr
        srl  a
        jr   nc,getitr
        ld   hl,curbin
        set  4,(hl)
getitr: ld   (37efh),a         ;Set track
        ld   c,18h
        call isscmd
        ld   hl,37ech
        ld   de,37efh
        ld   bc,secbuf
        call resel
        di
        ld   (hl),<dskcmd: 88h>
        call wait
        bit  0,a
        jr   z,getit5
        ld   a,(dskcmd)
        bit  5,a
        jr   z,getrd

; Write 1st & 2nd Byte

getwrt: ld   a,83h
        and  (hl)
        jp   po,getwrt
        ld   a,(bc)
        ld   (de),a
        inc  bc
        ld   a,(bc)
        ld   (savbyt),a
        inc  bc
        ld   a,1
getitb: cp   (hl)
        jr   z,getitb
        ld   a,<savbyt: 0>
        ld   (de),a
        ld   a,(bc)
        inc  bc
        bit  1,(hl)
        jr   nz,getit3
        bit  1,(hl)
        jr   nz,getit3
        jr   getit4

; Read

getrd:  ld   a,83h
        and  (hl)
        jp   po,getrd

; Move data

getit3: ld   a,(de)
        ld   (bc),a
        inc  bc
getit4: bit  1,(hl)
        jr   nz,getit3
        bit  1,(hl)
        jr   nz,getit3
        bit  1,(hl)
        jr   nz,getit3
        bit  0,(hl)
        jr   z,getit5
        bit  1,(hl)
        jr   nz,getit3
        bit  7,(hl)
        jr   z,getit4
getit5: ld   a,(hl)
        ld   (hl),0d0h
        pop  bc
        and  <dskerr: 0>
        jp   z,reperr          ;Ok if no error
        bit  4,a               ;Record not found ?
        call nz,restor         ;Y-restore
        dec  b
        jp   nz,getit1
        ld   a,b
        inc  a                 ;A = 1
reperr: ld   hl,errflg+1       ;Report error condition
        or   (hl)
        ld   (hl),a
        jp   swtcho

; Wait and get status

wait:   ld   a,20
wait1:  dec  a
        jr   nz,wait1
        ld   a,(37ech)
        ret

; Parameter table 3

destin: defw 0080h       ;dma adress
trktab: defb 0,0,0,0     ;track # table
wrtflg: defb 0           ;<> 0 if sector to write
newblk: defb 0           ;new sec # (logical)

pdrive: defs 15          ;pdrive specs
newpdb: defb 0           ;new pdrive byte
newbin: defb 0           ;new select (1/2/4/8)
newdrv: defb 0           ;new drive  (0/1/2/3)
newsid: defb 0           ;new side  (0=front, 1=back)
newtrk: defb 0           ;new trk # (logical & physical)
newsec: defb 0           ;new sec # (physical)

curpdb: defb 0           ;pdrive byte of current sector
curbin: defb 0           ;sel # to seek (in memory)
curdrv: defb 0           ;drv # to seek (in memory)
cursid: defb 0           ;sid # to seek (in memory)
curtrk: defb 0           ;trk # to seek (in memory)
cursec: defb 0           ;sec # to seek (in memory)

        page
; Cold start

boot:   ld   hl,pdtab
        ld   de,pdrive
        ld   bc,16
        ldir
        ld   a,0c3h
        ld   hl,intkbd
        ld   (38h),a
        ld   (39h),hl
        ld   a,1
        ld   (curbin),a
        call clrwrt
        ld   (curdrv),a
        ld   a,81h
        ld   (3),a
        xor  a
        ld   (4),a
        ld   (wrtflg),a
        ld   hl,stmsg
        call prttxt
        jp   wboot

prttxt: ld   a,(hl)
        ld   c,a
        or   a
        ret  z
        call conout
        inc  hl
        jr   prttxt

; Warm start

wboot:  ld   sp,0ffffh
        call readsk            ;Flush buffer
        ld   a,(pdtab+15)      ;A = pd-byte for drive a:
        and  05h
        or   05h
        ld   (curpdb),a        ;for next read operation
        ld   a,1
        out  (0f5h),a
        ld   (curbin),a

        call swtchi
        ld   hl,info
        ld   de,4380h
info1:  ld   a,(hl)
        or   a
        jr   z,infend
        or   80h
        ld   (de),a
        inc  hl
        inc  de
        jr   info1

infend: ld   a,0ffh            ;dden
        ld   (37ech),a
        ld   a,80h             ;5"
        ld   (37eeh),a
        ld   a,0d0h
        ld   (37ech),a
        ld   de,3400h+offset
        ld   bc,18*256+1
        call wbread
        ld   bc,4*256+2
        call wbread
        call swtcho
        jp   wboot1

wbread: ld   a,c
        ld   (curtrk),a
        xor  a
wbrd1:  ld   (cursec),a
        push bc
        push de
wbrd2:  ld   a,88h
        ld   de,021ah
        call getit
        jr   nz,wbrd2
        pop  de
        ld   hl,secbuf
        ld   bc,100h
        ldir
        pop  bc
        ld   a,(cursec)
        inc  a
        djnz wbrd1
        ret

wboot1: ld   hl,bios+3
        ld   a,0c3h
        ld   (0),a
        ld   (1),hl
        ld   hl,3c06h+offset
        ld   (5),a
        ld   (6),hl
        ld   hl,intkbd
        ld   (38h),a
        ld   (39h),hl
        ld   bc,0080h
        call setdma
        xor  a
        ld   (inlen),a
        ld   c,0
        call seldsk
        ld   a,(4)
        ld   c,a
        jp   3400h+offset

        page
; Drive paramter headers

dph:    defw cvtab1
        defw 0
        defw 0
        defw 0
        defw dirbuf
        defw pdrive
        defw csv1
        defw alv1

        defw cvtab2
        defw 0
        defw 0
        defw 0
        defw dirbuf
        defw pdrive
        defw csv2
        defw alv2

        defw cvtab3
        defw 0
        defw 0
        defw 0
        defw dirbuf
        defw pdrive
        defw csv3
        defw alv3

        defw cvtab4
        defw 0
        defw 0
        defw 0
        defw dirbuf
        defw pdrive
        defw csv4
        defw alv4

pdtab:  defw 36
        defb 4
        defb 15
        defb 1
        defw 82
        defw 63
        defw 0080h
        defw 16
        defw 3
        defb 05h

        defw 72
        defb 5
        defb 31
        defb 3
        defw 172
        defw 127
        defw 0080h
        defw 32
        defw 3
        defb 05h

        defw 36
        defb 4
        defb 15
        defb 1
        defw 82
        defw 63
        defw 0080h
        defw 16
        defw 3
        defb 05h

        defw 36
        defb 4
        defb 15
        defb 1
        defw 82
        defw 63
        defw 0080h
        defw 16
        defw 3
        defb 05h

cvtab1: defb 00,01,02,03,04,05,06,07
        defb 08,09,10,11,12,13,14,15
        defb 16,17,18,19,20,21,22,23
        defb 24,25,26,27,28,29,30,31
        defb 32,33,34,35,36,37,38,39
        defb 40,41,42,43,44,45,46,47
        defb 48,49,50,51,52,53,54,55
        defb 56,57,58,59,60,61,62,63
        defb 64,65,66,67,68,69,70,71
        defb 72,73,74,75,76,77,78,79

cvtab2: defb 00,01,02,03,04,05,06,07
        defb 08,09,10,11,12,13,14,15
        defb 16,17,18,19,20,21,22,23
        defb 24,25,26,27,28,29,30,31
        defb 32,33,34,35,164,165,166,167
        defb 168,169,170,171,172,173,174,175
        defb 176,177,178,179,180,181,182,183
        defb 184,185,186,187,188,189,190,191
        defb 192,193,194,195,196,197,198,199
        defb 200,201,202,203,204,205,206,207

cvtab3: defb 00,01,02,03,04,05,06,07
        defb 08,09,10,11,12,13,14,15
        defb 16,17,18,19,20,21,22,23
        defb 24,25,26,27,28,29,30,31
        defb 32,33,34,35,36,37,38,39
        defb 40,41,42,43,44,45,46,47
        defb 48,49,50,51,52,53,54,55
        defb 56,57,58,59,60,61,62,63
        defb 64,65,66,67,68,69,70,71
        defb 72,73,74,75,76,77,78,79

cvtab4: defb 00,01,02,03,04,05,06,07
        defb 08,09,10,11,12,13,14,15
        defb 16,17,18,19,20,21,22,23
        defb 24,25,26,27,28,29,30,31
        defb 32,33,34,35,36,37,38,39
        defb 40,41,42,43,44,45,46,47
        defb 48,49,50,51,52,53,54,55
        defb 56,57,58,59,60,61,62,63
        defb 64,65,66,67,68,69,70,71
        defb 72,73,74,75,76,77,78,79

; Pdrive info table for pd.com

rdtab:  defb 00h,0bh,00h,00h

        page

fkytab: defb 0
        defm 'DIR'                     ; F1
        defb 0dh,0
        defm 'PD'                      ; F2
        defb 0dh,0
        defm 'STAT '                   ; F3
        defb 0
        defm 'DDT'                     ; F4
        defb 0dh,0
        defm 'PD B:S40 DD'             ; F5
        defb 0dh,0
        defm 'PD B:GENIE III DSDD'     ; F6
        defb 0dh,0
        defm 'PD B:CPM3 1024'          ; F7
        defb 0dh,0
        defm 'PD B:S40 DD'             ; F8
        defb 0dh,0
        defm 'BASIC'                   ; F9
        defb 0dh,0
        defm 'AUTO '                   ; F10
        defb 0
        defm 'EDIT '                   ; F11
        defb 0
        defm 'RUN'                     ; F12
        defb 0dh,0
        defm 'LIST'                    ; F13
        defb 0dh,0
        defm 'SAVE "'                  ; F14
        defb 0
        defm 'LOAD "'                  ; F15
        defb 0
        defm 'SYSTEM'                  ; F16
        defb 0dh,0

        org  fkytab + 512

stmsg:  defb 26
        defm '64K Genie III CP/M 2.2'
        defb 07,13,10,0

info:   defm 'CP/M 2.2 Super-BIOS (c) Klaus K{mpf 5.84'
        defm ' Your Text goes here ...        HH:MM:SS'
        defb 0

; Parameter Table 4

zzzzzy  equ  $
        defs 100
cpmstk  equ  $
        defs 50
intstk  equ  $
kbdbuf: defs 32
secbuf: defs 1024
alv1:   defs 50
alv2:   defs 50
alv3:   defs 50
alv4:   defs 50
csv1:   defs 128
csv2:   defs 128
csv3:   defs 128
csv4:   defs 128
dirbuf: defs 128
zzzzzz  equ  $
        end
