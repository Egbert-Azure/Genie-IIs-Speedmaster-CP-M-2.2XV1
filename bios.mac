; Bios for CP/M 2.2
; (c) '84 Kalle Braun & Klaus K{mpf
; Source only for Z80-Macroassembler

        aseg

offset  equ  09e00h            ; 61 k
        org  4a00h+offset

        page 66
bios:   jp   boot
        jp   wboot
        jp   const
        jp   conin
        jp   conout
        jp   list
        ret
        nop
        nop
        xor  a
        ret
        nop
        jp   home
        jp   seldsk
        jp   settrk
        jp   setsec
        jp   setdma
        jp   read
        jp   write
        jp   listst
        jp   sectrn


savstk: di
        ex   (sp),hl
        ld   (retjmp),hl
        pop  hl
        ld   (usrstk),sp
        ld   sp,cpmstk
        push hl
        ld   hl,getstk
        ex   (sp),hl
        jp   <retjmp: dw 0>
getstk: ld   sp,<usrstk: dw 0>
        ei
        ret

swtchi: di
        ld   a,71h
switch: out  (0fah),a
        ret
swtcho: ld   a,7fh
        jr   switch

        page

const:  ld   a,(inlen)
        or   a
        ret  z
        ld   a,0ffh
        ret


conin:  ld   a,(inlen)
        or   a
        jr   z,conin
        push hl
        push de
        push bc
        ld   hl,kbdbuf+1
        ld   de,kbdbuf
        ld   bc,64
        ld   a,(de)
        ldir
        ld   hl,inlen
        dec  (hl)
        pop  bc
        pop  de
        pop  hl
        ret

; Interrupt Vector

intkbd: ld   (intret),sp
        ld   sp,intstk
        push af
        push hl
        push de
        push bc
        call swtchi
        ld   a,(37ech)
        ld   a,(37e1h)
        call clock
        call inkbd1
        call swtcho
        pop  bc
        pop  de
        pop  hl
        pop  af
        ld   sp,<intret: dw 0>
        ei
        reti


inkbd1: call inch1
        or   a
        jr   z,inkbd3
        ld   c,a
        ld   (rptchr),a
        ld   a,(rptcn1)
        ld   (rptcnt),a
inkbd2: ld   hl,inlen
        ld   a,(hl)
        cp   63
        jp   nc,pieps
        inc  (hl)
        ld   hl,kbdbuf
        ld   e,a
        ld   d,0
        add  hl,de
        ld   (hl),c
        ret

inkbd3: ld   hl,rptcnt
        dec  (hl)
        ret  nz
        ld   a,(381fh)
        or   a
        jr   nz,kyprsd
        ld   a,(3820h)
        or   a
        jr   nz,kyprsd
        ld   a,(3840h)
        or   a
        ld   a,(38c0h)
        or   a
        jr   nz,kyprsd
        ld   a,(38e0h)
        or   a
kyprsd: ret  z
        ld   a,(rptcn2)
        ld   (hl),a
        dec  hl
        ld   c,(hl)
        jr   inkbd2


clock:  ld   a,(clkcnt)
        dec  a
        jp   nz,clkend
        ld   hl,37e0h
clklo1: ld   a,(hl)
        rlca
        jr   c,clklo1
clklo2: ld   a,(hl)
        rlca
        jr   nc,clklo2
        ld   a,40h
        out  (0e1h),a
        ld   hl,clktab
        ld   de,0100fh
        ld   bc,006e0h
clklo3: bit  0,b
        jr   nz,nodot
        ld   (hl),0ah
        inc  hl
nodot:  ld   a,e
        out  (c),a
        add  d
        ld   e,a
        ini
        jr   nz,clklo3

        ld   de,437fh
        ld   b,8
clklo4: dec  hl
        ld   a,(hl)
        and  0fh
        or   30h + 80h
        ld   (de),a
        inc  de
        djnz clklo4
        ld   a,40

clkend: ld   (clkcnt),a
        ret


; Paramter Table 1

clkcnt: defb 40
clktab: defs 9
curchr: defb 0
rptchr: defb 0
rptcnt: defb 0
rptcn1: defb 013
rptcn2: defb 002
inlen:  defb 0
newrow: defb 0
cursor: defw 3c00h
invers: defb 0

cdeftb: defb 2bh
        defb 60h
        defb 00h
        defb 6bh
        defb 0bh

esctab: defb '.'
        defb '='
        defb '?'
        defb 'E'
        defb 'G'
        defb 'Q'
        defb 'R'
        defb 'T'
        defb 'W'
        defb 'Y'
        defb 'Z'

jmptab: defw line25
        defw eraeof
        defw delchr
        defw eraeol
        defw dellin
        defw inschr
        defw invert
        defw inslin
        defw curpos
        defw curadr
        defw curdef

; Ring the bell

bell:   call savstk
        call swtchi
        call pieps
        call swtcho
        xor  a
        ret

pieps:  push bc
        ld   bc,0b080h
bell1:  ld   a,(3860h)
        push bc
bell2:  dec  c
        jr   nz,bell2
        pop  bc
        djnz bell1
        pop  bc
        xor  a
        ret

        page
; Cursor > 437fh ?  Y->NC

toobig: ld   a,h
        cp   43h
        ret  c
        ld   a,l
        cp   80h
        ret


putcur: ld   de,3c00h
        ld   (cursor),hl
        or   a
        sbc  hl,de
        ld   c,0f6h
        ld   a,0eh
        out  (c),a
        inc  c
        out  (c),h
        dec  c
        inc  a
        out  (c),a
        inc  c
        out  (c),l
        ret

; compute line# in b

lineno: ld   de,0050h
        ld   b,0
        or   a
line1:  sbc  hl,de
        inc  b
        ld   a,h
        cp   3bh
        jr   nz,line1
        ret


conout: ld   a,(3)
        and  3
        cp   2
        jp   z,list
        cp   1
        ret  nz
        call savstk
        call swtchi
        push hl
        push de
        push bc
        ld   hl,<retadr: dw grend2>
        push hl
        ld   hl,(cursor)
        push hl
        ld   a,c
        jp   <escjmp: dw chrout>


chrout: pop  de                ;de = cursor
        cp   27
        jr   z,grendx
        ld   hl,grend0         ; change if NOT esc
        ex   (sp),hl

grendx: push de                ; (sp) = cursor
        cp   20h
        jr   c,ctrl


        pop  hl
        ld   a,(invers)
        or   c
        ld   (hl),a
        inc  hl
        ret                    ; to grend0

; common return

grend0: call toobig
        jr   c,grend2
        ld   hl,4330h
        call scroll

grend2: call swtcho
        call putcur
        pop  bc
        ld   a,c
        pop  de
        pop  hl
        ret

ctrl:   add  a,a
        ld   e,a
        ld   d,0
        ld   hl,gtab
        add  hl,de
        ld   a,(hl)
        inc  hl
        ld   h,(hl)
        ld   l,a
        ex   (sp),hl
        ret

; hl = cursor
;(sp)= grend0 if NOT esc
;(sp)= grend2 if esc

        page
; Control Character Table

gtab:   32:defw grnix
gtabed  equ  $
gcode   macro x,adr
        org   gtab+2*x
        defw  adr
        endm
        gcode 7,pieps
        gcode 8,back
        gcode 9,tab
        gcode 10,lf
        gcode 11,curup
        gcode 12,currgt
        gcode 13,cr
        gcode 14,curlft
        gcode 26,cls
        gcode 27,escape
        gcode 30,chome
        org  gtabed
grnix:  xor  a
        ret

back:   dec  hl
        ld   a,h
        cp   3bh
        jr   nz,back1
        inc  hl
        ret

back1:  ld   (hl),20h
        ret

cr:     call lineno
cr1:    ld   hl,3bb0h
cr2:    add  hl,de
        djnz cr2
        ret

crnext: call cr
        ld   de,79
        add  hl,de
        ret

lf:     ld   de,50h
        add  hl,de
        ret

tab:    ld   a,20h
        ld   (hl),a
        inc  hl
        call toobig
        jr   c,tab1
        call scroll
        ld   hl,4330h
tab1:   ld   a,l
        and  7
        jr   nz,tab
        ret

curup:  ld   de,0ffb0h
        add  hl,de
        ld   a,h
        cp   3bh
        ret  nz
        ld   de,50h
        add  hl,de
        ret

currgt: inc  hl
        call toobig
        ret  c
        dec  hl
        ret

curlft: dec  hl
        ld   a,h
        cp   3bh
        ret  nz
        inc  hl
        ret

chome:  ld   hl,3c00h
        ret

        page
; a = 27 (esc)

escape: push hl
        ld   hl,escap1
eschng: ld   (escjmp),hl
        pop  hl
        ret

escng1: ld   (escjmp),hl
        ld   hl,grend0
        ld   (retadr),hl
        pop  hl
        ret

; a = xx (after esc !)

escap1: ld   bc,jmptab-esctab
        ld   hl,esctab
        cpir
        jr   nz,escen1
        sla  c
        ld   hl,jmptab
        add  hl,bc
        ld   a,(hl)
        inc  hl
        ld   h,(hl)
        ld   l,a
        jp   (hl)

escend: push hl
escen1: ld   hl,grend2
        ld   (retadr),hl
        ld   hl,chrout
        jr   eschng

curadr: ld   hl,curad1
        jr   escng1

curdef: ld   hl,curdf1
        jr   escng1

invert: ld   hl,invrt1
        jr   escng1

line25: ld   hl,linoff
        jr   escng1

linoff: cp   80
        jp   nc,escen1
setoff: ld   (offset),a
linset: ld   hl,lintxt
        jr   escng1

lintxt: or   a
        jp   z,escen1
        or   80h
        ld   c,a
        ld   hl,4330h
        ld   a,(offset)
        ld   e,a
        ld   d,0
        add  hl,de
        ld   (hl),c
        inc  a
        cp   80
        jr   nc,linset
        jr   setoff

; new row

curad1: ld   (newrow),a
        ld   hl,curad2
        jr   escng1

; report cursor position

curpos: pop  hl
        push hl
        call lineno
        ld   a,b
        call cr1
        ex   de,hl
        pop  hl
        or   a
        sbc  hl,de
        add  a,20h
        ld   d,a
        ld   a,l
        add  a,20h
        ld   e,a
        jp   escend

inslin: push hl
        ex   de,hl
        ld   hl,432fh
        or   a
        sbc  hl,de
        jp   c,eraeol
        dec  hl
        ld   c,l
        ld   b,h
        ld   hl,432fh
        ld   de,437fh
        lddr
noins:  pop  de
noins1: ld   bc,79
        jp   filsp1

dellin: push hl
        ld   de,80
        add  hl,de
        ex   de,hl
        ld   hl,437fh
        or   a
        sbc  hl,de
        dec  hl
        ld   c,l
        ld   b,h
        ex   de,hl
        pop  de
        ld   a,b
        or   a
        jr   nz,delok
        ld   a,c
        cp   79
        jp   c,nodone
delok:  ldir
        ld   de,4330h
        jp   noins1

eraeol: pop  hl
        push hl
        call crnext
        pop  de
        jr   filspc

eraeof: pop  de
        ld   hl,437fh
filspc: or   a
        sbc  hl,de
        ld   b,h
        ld   c,l
filsp1: ld   h,d
        ld   l,e
        inc  de
        ld   (hl),20h
        ldir
        jp   nodone

inschr: pop  hl
        push hl
        call crnext
        pop  de
        push hl
        or   a
        sbc  hl,de
        pop  de
        jr   z,nodone
        ld   b,h
        ld   c,l
        ld   h,d
        ld   l,e
        dec  hl
        lddr
        inc  hl
        ld   (hl),20h
        jp   escend

delchr: pop  hl
        push hl
        call crnext
        pop  de
        or   a
        sbc  hl,de
        jr   z,nodone
        ld   b,h
        ld   c,l
        ld   h,d
        ld   l,e
        inc  hl
        ldir
        dec   hl
        ld   (hl),20h

nodone: ld   hl,(cursor)
        jp   escend

; new column

curad2: pop  hl
        ld   a,(newrow)
        sub  20h
        cp   24
        jr   c,curad3
        ld   a,0
curad3: ld   l,a
        ld   h,0
        ld   e,l
        ld   d,h
        add  hl,hl
        add  hl,hl
        add  hl,de
        add  hl,hl
        add  hl,hl
        add  hl,hl
        add  hl,hl
        ld   a,c
        sub  20h
        cp   80
        jr   c,curad4
        ld   a,0
curad4: ld   e,a
        ld   d,3ch
        add  hl,de
        jp   escend

invrt1: rrca
        rrca
        rrca
        and  80h
        ld   (invers),a
        jp   escen1

curdf1: sub  30h
        jp   c,escen1
        cp   5
        jp   nc,escen1
        ld   bc,cdeftb
curdf2: or   a
        jr   z,curdf3
        inc  bc
        dec  a
        jr   curdf2
curdf3: ld   a,0ah
        out  (0f6h),a
        ld   a,(bc)
        out  (0f7h),a
        jp   escen1

scroll: push hl
        push de
        push bc
        ld   hl,3c50h
        ld   de,3c00h
        ld   bc,730h
        ldir
        ld   hl,4330h
        ld   de,4331h
        ld   bc,4fh
        ld   (hl),20h
        ldir
        pop  bc
        pop  de
        pop  hl
        ret

cls:    ld   hl,3c00h
        push hl
        ld   de,3c01h
        ld   bc,077fh
        ld   (hl),20h
        ldir
        pop  hl
        ret

        page
inch1:  push hl
        push de
        push bc
        ld   a,(3840h)         ;clear ?
        ld   b,a
        ld   a,(3880h)         ;ctrl ?
        and  b
        bit  1,a
        jr   z,inchgo
        xor  a
        ld   (inlen),a
        jp   nokey

inchgo: ld   bc,3801h
        ld   hl,keybuf
        ld   d,0
keylop: ld   a,(bc)
        ld   e,a
        xor  (hl)
        and  e
        ld   (hl),e
        jr   nz,newkey
        inc  hl
        inc  d
        ld   a,d
        cp   8
        jr   nc,keypad
        rlc  c
        jr   keylop
keypad: cp   0bh
        jp   z,nokey
        ld   a,20h
        add  c
        ld   c,a
        jr   keylop

newkey: ld   e,a
        push bc
        ld   bc,500h
        call delay
        pop  bc
        ld   a,(bc)
        and  e
        jp   z,inchex

        ld   b,-1
inch13: inc  b
        rrca
        jr   nc,inch13
        ld   a,d
        rlca
        rlca
        rlca
        add  a,b
        ld   hl,kytab1
        ld   bc,9
        cpir
        jr   nz,nofoun
        ld   hl,kytab2
        add  hl,bc
        ld   a,(hl)
nofoun: ld   hl,3880h
        ld   c,(hl)
        ld   b,a
        cp   48h
        jr   nc,numkey
        cp   40h
        jp   nc,fkeys
        cp   20h
        jr   nc,inch16

        xor  a
        bit  1,c
        jr   nz,inch15
        bit  0,c
        jr   nz,inch14
        ld   a,(38e0h)
        bit  3,a
        ld   a,60h
        jr   z,inch15
inch14: ld   a,40h

inch15: add  a,b
        jr   inched

inch16: cp   2ch
        jr   nc,inch17
        xor  a
        bit  0,c
        jr   nz,inch15
        jr   inch99
inch17: cp   30h
        jr   nc,inch18
        xor  a
        bit  0,c
        jr   z,inch15
inch99: ld   a,10h
        jr   inch15

inch18: cp   38h
        jr   c,inch19
nokey:  xor  a
        jr   inchex

numkey: cp   52h
        jr   nc,numky1
        sub  48h
        add  30h
        jr   inched

numky1: jr   z,zero2
        sub  54h
        add  2ch
        jr   inched

zero2:  ld   hl,zerotx
        jp   fkyfou

inch19: ld   hl,ctltab
        sub  30h
        ld   c,a
        ld   b,0
        add  hl,bc
        add  hl,bc
        ld   a,(3880h)
        bit  0,a
        jr   z,inch20
        inc  hl
inch20: ld   a,(hl)
inched: ld   bc,2000h
        call delay
inchex: ld   b,a
        call swtcho
        ld   a,b
        pop  bc
        pop  de
        pop  hl
        ret

fkeys:  ld   hl,fkytab
        ld   bc,0100h
        sub  40h
        ld   d,a
        jr   z,fkyfou
        xor  a
fkylo1: cpir
        dec  d
        jr   nz,fkylo1

fkyfou: ld   c,l
        ld   b,h
        ld   a,(inlen)
        ld   e,a               ; d is zero !
        ld   hl,kbdbuf
        add  hl,de
        ex   de,hl
        ld   hl,inlen
fkylo2: ld   a,(hl)
        cp   63
        jp   nc,inched
        ld   a,(bc)
        or   a
        jp   z,inched
        ld   (de),a
        inc  bc
        inc  de
        inc  (hl)
        jr   fkylo2

delay:  push af
delay1: dec  bc
        ld   a,b
        or   c
        jr   nz,delay1
        pop  af
        ret

; Paramter Table 2

keybuf: defb 0,0,0,0,0,0,0,0,0,0,0
kytab1: defb 00h,19h,1ah,1bh,1ch,1dh,1eh,2ah,2bh
kytab2: defb 1ch,1eh,00h,2ah,1bh,2bh,19h,1ah,1dh
ctltab: defb 13,95,27,31,3,127,05,18
        defb 24,3,8,01,04,6,32,32
zerotx: defb '0','0',0
fkytab: defs 256

        page
; List output

list:   ld   a,(3)
        and  0c0h
        cp   40h
        jp   z,conout
        cp   80h
        ret  nz

list1:  call listst
        jr   z,list1
        ld   a,c
        out  (0fdh),a
        ret

; List status

listst: in   a,(0fdh)
        and  0f0h
        cp   30h
        ld   a,0
        jr   nz,lists1
        dec  a
lists1: or   a
        ret

        page
; ** Select Disk

seldsk: call savstk
        push de
        push bc
        call chkwrt            ;Sector to write ?
        jr   nz,seld2          ;jp if error
        pop  bc
        push bc
        call swtchi
        ld   a,c
        cp   4
        jr   nc,seld2
        and  3
        inc  a
        ld   b,80h
seld1:  rlc  b
        dec  a
        jr   nz,seld1
        bit  0,e
        jr   nz,seld4
        ld   a,b
        ld   (37e1h),a
        ld   a,0d0h
        ld   (37ech),a
        ld   a,(37ech)
        and  2
        ld   e,a
        ld   hl,8000h
seld11: ld   a,(37ech)
        and  2
        xor  e
        jr   nz,seld4
        dec  hl
        ld   a,h
        or   l
        jr   nz,seld11
seld2:  ld   hl,0
seld3:  call swtcho
        pop  bc
        pop  de
        ret

seld4:  ld   a,(drvbin)        ; New drive ?
        xor  b
        ld   (selflg),a
        ld   a,b
        ld   (drvbin),a
        ld   a,(drvasc)
        ld   hl,trktab
        ld   e,a
        ld   d,0
        add  hl,de
        ld   a,(37edh)
        ld   (hl),a
        ld   a,c
        ld   (drvasc),a
        ld   hl,trktab
        ld   e,a
        ld   d,0
        add  hl,de
        ld   a,(hl)
        ld   (37edh),a
        ld   l,c
        ld   h,0
        add  hl,hl
        add  hl,hl
        add  hl,hl
        add  hl,hl
        push hl
        ld   de,pdtab
        add  hl,de
        ld   de,pdrive
        ld   bc,16
        ldir
        pop  hl
        ld   de,dph
        add  hl,de
        jr   seld3

; ** Set new track

settrk: ld   a,c
        ld   (newtrk),a
        ret

; ** Set new sector

setsec: ld   (newblk),bc
        ret

; ** Set new destination adress

setdma: ld   (destin),bc
        ret

; ** Read logical record

read:   call savstk
        push hl
        push de
        push bc
        ld   hl,rwret
        push hl
        call samsec
        jp   z,reamem
        call chkwrt
        call readsk
        jp   reamem

; ** Write logical record

write:  call savstk
        push hl
        push de
        push bc
        ld   hl,rwret
        push hl
        ld   a,c               ; directory sec ?
        cp   1
        jr   z,write1

        call samsec
        jp   z,wrtmem
        call chkwrt
        call readsk
        jp   wrtmem

write1: call chkwrt            ; sec to write ?
        call samsec            ; comp phys sec & set newsec
        call nz,readsk         ; Read new phys sec
        call wrtmem
        jp   wrtdsk            ; Write sec to disk

; Common return

rwret:  pop  bc
        pop  de
        pop  hl
        xor   a
        ret

; ** Translate sector number
;    translates always

sectrn: ex   de,hl
        ld   b,0
        add  hl,bc
        ld   c,(hl)
        ex   de,hl
        ld   h,b
        ld   l,c
        ret

; ** Home diskhead

home:   call savstk
        call chkwrt
        xor  a
        ld   (newtrk),a
        ret

; Restore drivehead

restor: ld   c,50h
        call isscmd
        ld   c,0
        jp   isscmd

; Check if same physical sector (Y -> Z)
; and set newsec

samsec: call secno             ;compute phys sec & set newsec
        ld   a,(cursec)
        cp   c                 ;new sec ?
        ret  nz
        ld   a,(curtrk)
        ld   b,a
        ld   a,(newtrk)
        cp   b                 ;new trk ?
        ret  nz
        ld   a,(cursid)
        ld   b,a
        ld   a,(newsid)
        cp   b                 ;new side ?
        ret  nz
        ld   a,(selflg)
        or   a                 ;new drive ?
        ret

; check if sector to write

chkwrt: ld   a,(wrtflg)
        or   a
        ret  z
        jp   wrtdsk

; set & reset writeflag

setwrt: ld   a,<clrwrt: xor a>
        ld   (wrtflg),a
        ret

; read record from memory

reamem: call getblk
        jp   move

; write record to memory

wrtmem: call getblk
        ex   de,hl
        call move
        jp   setwrt

; Move logical record

move:   ld   bc,0080h
        ldir
        ret

; Read physical sector from newtrk, newsec
; & set curtrk = newtrk, cursec = newsec

readsk: xor  a
        ld   (selflg),a
        ld   a,(newsid)
        ld   (cursid),a
        ld   a,(newsec)
        ld   (cursec),a
        ld   a,(newtrk)
        ld   (curtrk),a
        ld   a,88h
        ld   de,021ah
        jp   getit

; Write physical sector

wrtdsk: ld   a,0a8h
        ld   de,0a12h
        call getit
        jp   clrwrt

; Translate logical -> physical & select side

secno:  ld   hl,drvbin
        ld   bc,(newblk)
        res  4,(hl)
        xor  a
        bit  7,c               ; Backside ?
        jr   z,setsid
        set  4,(hl)
        inc  a
setsid: ld   (newsid),a
        ld   a,7fh
        and  c
        ld   c,a
        ld   a,(pdrive+15)
        rrca
        rrca
        and  3
        inc  a
seclop: dec  a
        jr   z,secno1
        srl  c
        jr   seclop
secno1: ld   a,c
        ld   (newsec),a
        ret

; Compute buffer adress

getblk: ld   bc,(newblk)
        ld   a,(pdrive+15)
        rrca
        rrca
        and  3
        ld   b,a
        inc  b
        xor  a
getbl1: scf
        adc  a,a
        djnz getbl1
        srl  a
        and  c
        ld   l,a
        ld   h,0
        add  hl,hl
        add  hl,hl
        add  hl,hl
        add  hl,hl
        add  hl,hl
        add  hl,hl
        add  hl,hl
        ld   bc,secbuf
        add  hl,bc
        ld   de,(destin)
        ret

; set density & size

select: ld   a,(pdrive+15)
        ld   b,a
        ld   hl,37ech
        and  1
        or   0feh
        ld   (hl),a            ;Select density
        ld   (hl),0d0h
        inc  hl
        inc  hl
        ld   a,b
        and  40h
        or   80h
        ld   (hl),a            ;Select size
        ld   a,0d0h
        ld   (37ech),a

; reselect drive

resel:  ld   a,(drvbin)
        ld   (37e1h),a
        ret

; Issue head moving cmd

isscmd: call resel
        ld   a,(pdrive+15)
        and  2
        or   c
        ld   (37ech),a
iss1:   call wait
        bit  0,a
        ret  z
        call resel
        jr   iss1

; Perform disk I/O on cursid, curtrk, cursec

getit:  ld   (dskcmd),a
        ld   b,1ch
        bit  5,a
        jr   z,getit0
        ld   b,7ch
getit0: ld   a,b
        ld   (dskerr),a
        ld   (getit3),de
        call swtchi
        call select
        ld   b,5               ;No of retries
getit1: push bc
        ld   a,(cursec)
        ld   (37eeh),a         ;Set sector
        ld   hl,pdrive+15
        ld   a,(curtrk)
        bit  5,(hl)            ;Double track ?
        jr   z,getitq
        sla  a
getitq: bit  4,(hl)            ;Double sided ?
        jr   z,getitr
        srl  a
        jr   nc,getitr
        ld   hl,drvbin
        set  4,(hl)
getitr: ld   (37efh),a         ;Set track
        ld   c,18h
        call isscmd
        ld   hl,37ech
        ld   de,37efh
        ld   bc,secbuf
        call resel
        di
        ld   (hl),<dskcmd: 88h>
        call wait
        bit  0,a
        jr   z,getit5
        ld   a,(dskcmd)
        bit  5,a
        jr   z,getrd

; Write 1st & 2nd Byte

getwrt: ld   a,83h
        and  (hl)
        jp   po,getwrt
        ld   a,(bc)
        ld   (de),a
        inc  bc
        ld   a,(bc)
        ld   (savbyt),a
        inc  bc
        ld   a,1
getitb: cp   (hl)
        jr   z,getitb
        ld   a,<savbyt: 0>
        ld   (de),a
        ld   a,(bc)
        inc  bc
        bit  1,(hl)
        jr   nz,getit3
        bit  1,(hl)
        jr   nz,getit3
        jr   getit4

; Read

getrd:  ld   a,83h
        and  (hl)
        jp   po,getrd

; Move data

getit3: ld   a,(de)
        ld   (bc),a
        inc  bc
getit4: bit  1,(hl)
        jr   nz,getit3
        bit  1,(hl)
        jr   nz,getit3
        bit  1,(hl)
        jr   nz,getit3
        bit  0,(hl)
        jr   z,getit5
        bit  1,(hl)
        jr   nz,getit3
        bit  7,(hl)
        jr   z,getit4
getit5: ld   a,(hl)
        ld   (hl),0d0h
        pop  bc
        and  <dskerr: 0>
        jp   z,swtcho          ;Ok if no error
        bit  4,a               ;Record not found ?
        call nz,restor         ;Y-restore
        dec  b
        jp   nz,getit1

; Report error condition

        call pieps
        ld   hl,cursid
        ld   a,'0'
        add  a,(hl)
        ld   (txtsid),a
        inc  hl
        ld   a,(hl)
        add  a,0a0h
        ld   (txttrk),a
        inc  hl
        ld   a,(hl)
        add  a,0a0h
        ld   (txtsec),a

        ld   hl,errtxt
        ld   de,4380h
        ld   a,(hl)
errlop: or   80h
        ld   (de),a
        inc  hl
        inc  de
        ld   a,(hl)
        or   a
        jr   nz,errlop
waitky: ld   a,(3840h)
        cp   06h               ;clr & brk ?
        jr   nz,waitky
        xor  a
        ld   (4),a
        jp   0

; Wait and get status

wait:   ld   a,20
wait1:  dec  a
        jr   nz,wait1
        ld   a,(37ech)
        ret

; Parameter table 3

destin: defw 0080h             ;dma adress
trktab: defb 0,0,0,0           ;track # table
pdrive: defs 16                ;pdrive specs
drvbin: defb 0                 ;select code
drvasc: defb 0                 ;drive #
wrtflg: defb 0                 ;<> 0 if sector to write
selflg: defb 0                 ;<> 0 if new drive
newblk: defw 0                 ;new sec # (logical)

newsid: defb 0                 ;new side  (0=front, 1=back)
newtrk: defb 0                 ;new trk # (logical & physical)
newsec: defb 0                 ;new sec # (physical)

cursid: defb 0                 ;sid # to seek (in memory)
curtrk: defb 0                 ;trk # to seek (in memory)
cursec: defb 0                 ;sec # to seek (in memory)

        page
; Cold start

boot:   ld   hl,pdtab
        ld   de,pdrive
        ld   bc,16
        ldir
        ld   a,0c3h
        ld   hl,intkbd
        ld   (38h),a
        ld   (39h),hl
        ld   a,1
        ld   (drvbin),a
        call clrwrt
        ld   (drvasc),a
        ld   a,81h
        ld   (3),a
        xor  a
        ld   (4),a
        ld   hl,stmsg
        call prttxt
        jp   wboot

prttxt: ld   a,(hl)
        ld   c,a
        or   a
        ret  z
        call conout
        inc  hl
        jr   prttxt

; Warm start

wboot:  ld   sp,0ffffh
        call chkwrt
        ld   a,(pdtab+15)
        and  05h
        or   05h
        ld   (pdrive+15),a
        ld   a,1
        out  (0f5h),a
        ld   (drvbin),a

        call swtchi
        ld   hl,info
        ld   de,4380h
info1:  ld   a,(hl)
        or   a
        jr   z,infend
        or   80h
        ld   (de),a
        inc  hl
        inc  de
        jr   info1

infend: ld   a,0ffh            ;dden
        ld   (37ech),a
        ld   a,80h             ;5"
        ld   (37eeh),a
        ld   a,0d0h
        ld   (37ech),a
        ld   de,3400h+offset
        ld   bc,18*256+1
        call wbread
        ld   bc,4*256+2
        call wbread
        call swtcho
        jp   wboot1

wbread: ld   a,c
        ld   (curtrk),a
        xor  a
wbrd1:  ld   (cursec),a
        push bc
        push de
wbrd2:  ld   a,88h
        ld   de,021ah
        call getit
        jr   nz,wbrd2
        pop  de
        ld   hl,secbuf
        ld   bc,100h
        ldir
        pop  bc
        ld   a,(cursec)
        inc  a
        djnz wbrd1
        ret

wboot1: ld   hl,bios+3
        ld   a,0c3h
        ld   (0),a
        ld   (1),hl
        ld   hl,3c06h+offset
        ld   (5),a
        ld   (6),hl
        ld   hl,intkbd
        ld   (38h),a
        ld   (39h),hl
        ld   bc,0080h
        call setdma
        xor  a
        ld   (inlen),a
        ld   c,0
        call seldsk
        ld   a,(4)
        ld   c,a
        jp   3400h+offset

        page
; Drive paramter headers

dph:    defw cvtab1
        defw 0
        defw 0
        defw 0
        defw dirbuf
        defw pdrive
        defw csv1
        defw alv1

        defw cvtab2
        defw 0
        defw 0
        defw 0
        defw dirbuf
        defw pdrive
        defw csv2
        defw alv2

        defw cvtab3
        defw 0
        defw 0
        defw 0
        defw dirbuf
        defw pdrive
        defw csv3
        defw alv3

        defw cvtab4
        defw 0
        defw 0
        defw 0
        defw dirbuf
        defw pdrive
        defw csv4
        defw alv4

pdtab:  defw 36
        defb 4
        defb 15
        defb 1
        defw 82
        defw 63
        defw 0080h
        defw 16
        defw 3
        defb 05h

        defw 72
        defb 5
        defb 31
        defb 3
        defw 172
        defw 127
        defw 0080h
        defw 32
        defw 3
        defb 05h

        defw 36
        defb 4
        defb 15
        defb 1
        defw 82
        defw 63
        defw 0080h
        defw 16
        defw 3
        defb 05h

        defw 36
        defb 4
        defb 15
        defb 1
        defw 82
        defw 63
        defw 0080h
        defw 16
        defw 3
        defb 05h

cvtab1: defb 00,01,02,03,04,05,06,07
        defb 08,09,10,11,12,13,14,15
        defb 16,17,18,19,20,21,22,23
        defb 24,25,26,27,28,29,30,31
        defb 32,33,34,35,36,37,38,39
        defb 40,41,42,43,44,45,46,47
        defb 48,49,50,51,52,53,54,55
        defb 56,57,58,59,60,61,62,63
        defb 64,65,66,67,68,69,70,71
        defb 72,73,74,75,76,77,78,79

cvtab2: defb 00,01,02,03,04,05,06,07
        defb 08,09,10,11,12,13,14,15
        defb 16,17,18,19,20,21,22,23
        defb 24,25,26,27,28,29,30,31
        defb 32,33,34,35,164,165,166,167
        defb 168,169,170,171,172,173,174,175
        defb 176,177,178,179,180,181,182,183
        defb 184,185,186,187,188,189,190,191
        defb 192,193,194,195,196,197,198,199
        defb 200,201,202,203,204,205,206,207

cvtab3: defb 00,01,02,03,04,05,06,07
        defb 08,09,10,11,12,13,14,15
        defb 16,17,18,19,20,21,22,23
        defb 24,25,26,27,28,29,30,31
        defb 32,33,34,35,36,37,38,39
        defb 40,41,42,43,44,45,46,47
        defb 48,49,50,51,52,53,54,55
        defb 56,57,58,59,60,61,62,63
        defb 64,65,66,67,68,69,70,71
        defb 72,73,74,75,76,77,78,79

cvtab4: defb 00,01,02,03,04,05,06,07
        defb 08,09,10,11,12,13,14,15
        defb 16,17,18,19,20,21,22,23
        defb 24,25,26,27,28,29,30,31
        defb 32,33,34,35,36,37,38,39
        defb 40,41,42,43,44,45,46,47
        defb 48,49,50,51,52,53,54,55
        defb 56,57,58,59,60,61,62,63
        defb 64,65,66,67,68,69,70,71
        defb 72,73,74,75,76,77,78,79

; Pdrive info table for pd.com

rdtab:  defb 00h,0bh,00h,00h

stmsg:  defb 26
        defm '64K Genie III CP/M 2.2'
        defb 07,13,10,0

info:   defm 'CP/M 2.2 Super-BIOS (c) Klaus K{mpf 5.84'
        defm ' A: S40 DD           B:GENIE III DSDD   '
        defb 0

errtxt: defm 'DISK ERROR !   Press CLEAR & BREAK      '
        defm 'Side: '
txtsid: defm '   '
        defm 'Track: '
txttrk: defm '   '
        defm 'Sector: '
txtsec: defm '             '
        defb 0

; Parameter Table 4

zzzzzy  equ  $
        defs 100
cpmstk  equ  $
        defs 50
intstk  equ  $
kbdbuf: defs 64
secbuf: defs 1024
alv1:   defs 50
alv2:   defs 50
alv3:   defs 50
alv4:   defs 50
csv1:   defs 128
csv2:   defs 128
csv3:   defs 128
csv4:   defs 128
dirbuf: defs 128
zzzzzz  equ  $
        end
