	.z80
	org	100h
;
; Version 2.1 vom 17.10.84
; Version 2.12 vom 24.01.86 (Select)

true    equ  0ffh
false   equ  000h

oldkbd  equ  true		;True if old Keyboard

buflen  equ  64			;Lenght of Keyboard Buffer


offset  equ  09d00h            ; 61 k (?)
        .phase	4a00h+offset
;
; Bios for CP/M 2.2
; Skeletal BIOS (c) Kalle Braun
; Genie III adaptions and extensions (c)'84
; by Klaus K{mpf
; Source only for Z80-Macroassembler
;
;
;
;
; Pdrive-Byte:                                  ( 0/ 1)
;
; 7   6   5   4   3   2   1   0
; !   !   !   !   !   !   !   --- Density Flag  (SD/DD)
; !   !   !   !   !   !   ------- Stepping Rate (6/12ms)
; !   !   !   !   --------------- Sector Length
; !   !   !   ------------------- Double Sided
; !   !   ----------------------- Double Track
; !   --------------------------- Size          (5"/8")
; ------------------------------- Inverted Sect.(N/Y)








        TITLE GENIE III CP/M 2.2X CBIOS
        SUBTTL (c),(p) Klaus K{mpf 1984
        page 70
bios:   jp   boot
        jp   wboot
        jp   const
        jp   conin
        jp   conout
        jp   list
        ret
        nop
        nop
        ld   a,1ah
        ret
        jp   home
        jp   seldsk
        jp   settrk
        jp   setsec
        jp   setdma
        jp   read
        jp   write
        jp   listst
        jp   sectrn
        jp   close             ;Close File extension
        page
; Save userstack

savstk: di
        ex   (sp),hl
        ld   (retjmp),hl
        pop  hl
        ld   (usrstk),sp
        ld   sp,cpmstk
        push hl
        ld   hl,getstk
        ex   (sp),hl
        jp   <retjmp: dw 0>
getstk: ld   sp,<usrstk: dw 0>
        ei
        ret


; Switch I/O Bank in & out

swtchi: di
        ld   a,71h
        jr   switch
swtcho: ld   a,7fh
switch: out  (0fah),a
        ret


; Interrupt Vector

intkbd: ld   (intret),sp
        ld   sp,intstk
        push af
        push hl
        push de
        push bc
        call swtchi
        ld   a,(37ech)
        ld   a,(37e1h)
        call clock
        call inkbd1
        call show
        call swtcho
        pop  bc
        pop  de
        pop  hl
        pop  af
        ld   sp,<intret: dw 0>
        ei
        reti

; Ring the bell

bell:   nop                    ;Bell Flag
        push bc
        ld   bc,0b080h
bell1:  ld   a,(3860h)
        push bc
bell2:  dec  c
        jr   nz,bell2
        pop  bc
        djnz bell1
        pop  bc
        xor  a
        ret
        page
clock:  nop                    ;Clock Flag
        ld   a,(clkcnt)
        dec  a
        jp   nz,clkend
        ld   hl,37e0h
clklo1: ld   a,(hl)
        rlca
        jr   c,clklo1
clklo2: ld   a,(hl)
        rlca
        jr   nc,clklo2
        ld   a,40h
        out  (0e1h),a
        ld   hl,clktab
        ld   de,0100fh
        ld   bc,006e0h
clklo3: bit  0,b
        jr   nz,nodot
        ld   (hl),0ah
        inc  hl
nodot:  ld   a,e
        out  (c),a
        add  a,d
        ld   e,a
        ini
        jr   nz,clklo3
        dec  hl
        res  2,(hl)
        res  3,(hl)

        ld   de,43c8h
        ld   b,8
clklo4: ld   a,(hl)
        and  0fh
        or   30h + 80h
        ld   (de),a
        inc  de
        dec  hl
        djnz clklo4
        ld   a,40

clkend: ld   (clkcnt),a
        ret

; Show current Keyboardbuffer at Statusline

show:   ret                    ;Showflag
        ld   hl,kbdbuf
        ld   de,4380h
        ld   a,(inlen)
        or   a
        jr   z,show1
        ld   c,a
        ld   b,0
        ldir
show1:  ex   de,hl
        ld   (hl),20h
bufclr: inc  hl
        ld   a,l
        cp   0c8h              ;Max. to Clock
        ret  z
        ld   (hl),0a0h
        jr   bufclr
        page
; Get console status

const:  ld   a,(inlen)
        or   a
        ret  z
        ld   a,0ffh
        ret

; Console input

conin:  ld   a,(inlen)
        or   a
        jr   z,conin
        ld   hl,kbdbuf+1
        ld   de,kbdbuf
        ld   bc,buflen-1
        ld   a,(de)
        res  7,a
        ldir
        ld   hl,inlen
        dec  (hl)
        ret

inkbd1: call inch1
        or   a
        jr   z,inkbd3
        ld   c,a
        ld   (rptchr),a
        ld   a,(rptcn1)
        ld   (rptcnt),a
inkbd2: call click
        ld   hl,inlen
        ld   a,(hl)
        cp   buflen
        jp   nc,bell
        inc  (hl)
        ld   hl,kbdbuf
        ld   e,a
        ld   d,0
        add  hl,de
        set  7,c
        ld   (hl),c
        ret

inkbd3: nop                    ;Repeat Flag
        ld   hl,rptcnt
        dec  (hl)
        ret  nz
        ld   a,(381fh)
        or   a
        jr   nz,kyprsd
        ld   a,(3820h)
        or   a
        jr   nz,kyprsd
        ld   a,(3840h)
        or   a
        ret  z
kyprsd: ld   a,(rptcn2)
        ld   (hl),a
        dec  hl
        ld   c,(hl)
        jr   inkbd2
        page
inch1:  ld   a,(3840h)
        ld   b,a
        cp   0e0h              ;spc,<-,->
        jr   z,showit
        ld   a,(3880h)         ;ctrl or shift ?
        ld   c,a
        and  03h
        jp   z,getkey          ;N: jp
        ld   a,b
        sub  02h               ;clear ?
        jr   nz,notclr
        bit  0,c               ;shift ? Y: jp
        jr   nz,notclr         ;only ctrl-clear
        ld   (inlen),a         ;sets inlen to 0
ctlend: jp   nokey

notclr: ld   a,c
        cp   03h               ;shift and ctrl ?
        jr   z,ctlend          ;not allowed
        ld   a,(38c0h)         ;0 - 7 ?
        or   a
        jr   nz,chnflg         ;Y: chnflg
        ld   a,(38e0h)
        bit  2,a               ;00 ?
        jp   z,getkey
        bit  0,c               ;shift ?
        jp   nz,getkey         ;Y: only ctrl-00 allowed

prtscr: ld   hl,3c00h
        ld   de,0780h
prtsc1: ld   b,80              ;80 Char/Line
prtsc2: ld   c,(hl)
        res  7,c
        call list1
        inc  hl
        dec  de
        djnz prtsc2
        ld   c,0dh
        call list1
        ld   c,0ah
        call list1
        ld   a,d
        or   e
        jr   nz,prtsc1
        jr   ctlend

showit: call save25
        ld   hl,vertxt
        call load25+3
showi1: ld   a,(3840h)
        cp   0e0h
        jr   z,showi1
        call load25            ;Display Normal Info
        jr   ctlend

chnflg: push af                ;c = (3880h)
        push bc
        ld   b,8
chnfl1: rlca
        jr   c,flgfou
        djnz chnfl1
flgfou: push bc
        call save25
        pop  bc
        ld   hl,adrtab-4
        ld   e,b
        ld   d,0
      4:add  hl,de
        ld   c,(hl)            ;(bc) = text
        inc  hl
        ld   b,(hl)
        inc  hl
        ld   de,4380h
chnfl2: ld   a,(bc)
        xor  80h
        jr   z,chnfl3
        ld   (de),a
        inc  bc
        inc  de
        jr   chnfl2
chnfl3: ld   a,(hl)            ;(hl) = flag
        inc  hl
        ld   h,(hl)
        ld   l,a
        pop  bc
        ld   a,(hl)            ;a = flag
        bit  0,c               ;shift ?
        jr   nz,shoflg         ;Y: show flag
notsft: xor  0c9h              ;ctrl !
        ld   (hl),a
        jr   shofl1
shoflg: ld   hl,txtis          ;' ist'
        ld   bc,4
        ldir
shofl1: or   a
        ld   hl,txton
        jr   z,chnfl4
        ld   hl,txtoff
chnfl4: ld   bc,4
        ldir
        ex   de,hl
chnfl5: ld   (hl),0a0h
        inc  hl
        ld   a,l
        sub  0d0h
        jr   nz,chnfl5
        pop  bc                ;B = keycode !
chnfl6: ld   a,(38c0h)
        xor  b
        jr   z,chnfl6          ;wait for key-release
        xor  a
        call load25
        jp   inched
        page
getkey: ld   bc,3801h
        ld   hl,keybuf
        ld   d,0
keylop: ld   a,(bc)
        ld   e,a
        xor  (hl)
        and  e
        ld   (hl),e
        jr   nz,newkey
        inc  hl
        inc  d
        ld   a,d
        cp   8
        jr   nc,keypad
        rlc  c
        jr   keylop
keypad: cp   0bh
        jp   z,nokey
        ld   a,20h
        add  a,c
        ld   c,a
        jr   keylop

newkey: ld   e,a
        push bc
        ld   bc,500
        call delay
        pop  bc
        ld   a,(bc)
        and  e
        ret  z

        ld   b,-1
inch13: inc  b
        rrca
        jr   nc,inch13
        ld   a,d
        rlca
        rlca
        rlca
        add  a,b

        if   oldkbd

        ld   hl,kytab1
        ld   bc,9
        cpir
        jr   nz,nofoun
        ld   hl,kytab2
        add  hl,bc
        ld   a,(hl)

        endif

nofoun: ld   hl,3880h
        ld   c,(hl)
        ld   b,a
        cp   48h
        jr   nc,numkey
        cp   40h
        jp   nc,fkeys
        cp   20h
        jr   nc,noalfa

        xor  a
        bit  1,c               ;ctrl ?
        jr   nz,addoff         ;Y: no offset
        ld   a,b
        or   a
        jr   nz,notat
        ld   a,40h
        bit  0,c
        jr   z,addoff
        ld   a,60h
        jr   addoff

notat:  ld   a,(38e0h)
        bit  3,a               ;lock ?
        ld   a,40h
        jr   nz,addoff         ;Y: offset = 40h
        bit  0,c               ;shift ?
        jr   nz,addoff         ;Y: offset = 40h
        ld   a,60h

addoff: add  a,b
        jr   inched

noalfa: cp   2ch
        jr   nc,inch17
        xor  a
        bit  0,c
        jr   nz,addoff
        jr   inch99

inch17: cp   30h
        jr   nc,inch18
        xor  a
        bit  0,c
        jr   z,addoff
inch99: ld   a,10h
        jr   addoff

inch18: cp   38h
        jr   c,inch19
nokey:  xor  a
        ret

numkey: ld   a,c
        or   a
        jr   nz,nokey          ;shift or ctrl
        ld   a,b
        cp   52h
        jr   nc,numky1
        sub  48h
        add  a,30h
        jr   inched

numky1: jr   z,zero2
        sub  54h
        jr   c,nokey
        add  a,2ch
        jr   inched

zero2:  ld   hl,zerotx
        jp   fkyfou

inch19: ld   hl,ctltab
        sub  30h
        ld   e,a
        ld   d,0
        add  hl,de
        add  hl,de
        bit  0,c
        jr   z,inch20
        inc  hl
inch20: ld   a,(hl)
inched: ld   bc,4000
        jp   delay

fkeys:  ld   hl,fkytab
        sub  40h
        bit  0,c               ;shift ?
        jr   z,f1f8
        add  a,8               ;Y: F9 - F16
f1f8:   ld   d,a
        inc  d
        xor  a
        ld   bc,0200h
fkylo1: cpir
        dec  d
        jr   nz,fkylo1

fkyfou: call click
        ld   c,l
        ld   b,h
        ld   a,(inlen)
        ld   e,a
        ld   d,0
        ld   hl,kbdbuf
        add  hl,de
        ex   de,hl
        ld   hl,inlen
fkylo2: ld   a,(hl)
        cp   buflen
        jp   nc,inched
        ld   a,(bc)
        or   a
        jp   z,inched
        set  7,a
        ld   (de),a
        inc  bc
        inc  de
        inc  (hl)
        jr   fkylo2

delay:  push af
delay1: dec  bc
        ld   a,b
        or   c
        jr   nz,delay1
        pop  af
        ret

click:  nop                    ;Clickflag
        push af
        push bc
        ld   bc,04040h
click1: ld   a,(3860h)
        push bc
click2: dec  c
        jr   nz,click2
        pop  bc
        djnz click1
        pop  bc
        pop  af
        ret
        page
; Paramter Table 1

keybuf: defb 0,0,0,0,0,0,0,0,0,0,0

        if   oldkbd

kytab1: defb 00h,19h,1ah,1bh,1ch,1dh,1eh,2ah,2bh
kytab2: defb 1ch,1eh,00h,2ah,1bh,2bh,19h,1ah,1dh

        endif

ctltab: defb 13,95,27,31,3,127,05,18
        defb 24,3,8,01,04,6,32,09
zerotx: defb '0','0',0

; Paramter Table 2

clkcnt: defb 40                ;40 ints per sec
clktab: defs 9                 ;9 Bytes for TIME$
rptchr: defb 0                 ;Repeat char
rptcnt: defb 0                 ;Repeat count
rptcn1: defb 032               ;Time until 1st rpt
rptcn2: defb 005               ;Repeat interval
inlen:  defb 0                 ;Buffer lenght
        page
; Parameter Table 3

newrow: defb 0                 ;New row for ESC =
invers: defb 0                 ;Invers flag
cursor: defw 3c00h             ;Current cursor adress
scrtop: defw 3c00h             ;first unprot. pos.
scrlst: defw 4330h             ;start of last line
scrbot: defw 437fh             ;last unprot. pos.

; Control Character Table

gtab:
	defw grnix	;0
	defw grnix
	defw grnix
	defw grnix
	defw grnix
	defw grnix	;5
	defw grnix
        defw	bell
        defw	back
        defw	tab
        defw	lf	;10
        defw	curup
        defw	currgt
        defw	cr
	defw grnix
	defw grnix	;15
	defw grnix
	defw grnix
	defw grnix
	defw grnix
	defw grnix	;20
	defw grnix
        defw	curdo
	defw grnix
	defw grnix
	defw grnix	;25
        defw	cls
        defw	escape
	defw grnix
	defw grnix
        defw	chome	;30
        defw	crlf
grnix:  xor  a
        ret

esctab: defb '.'               ;Cursor Definition
        defb '='               ;Cursor Adressing
        defb '?'               ;Cursor Position
        defb 'E'               ;Insert Line
        defb 'R'               ;Delete Line
        defb 'Q'               ;Insert Char
        defb 'W'               ;Delete Char
        defb 'T'               ;Erase to end of line
        defb 'Y'               ;Erase to end of frame
        defb ')'               ;Invers on
        defb '('               ;Invers off
        defb '<'               ;Scroll protect top
        defb '>'               ;Scroll protect bottom
        defb 'Z'               ;Line 25
        defb '*'               ;Clear screen
        defb 'G'               ;Set Video Attribute
        defb 'j'               ;Reverse Linefeed

jmptab: defw rvrslf
        defw setatt
        defw clscrn
        defw line25
        defw scprbo
        defw scprto
        defw invoff
        defw invon
        defw eraeof
        defw eraeol
        defw delchr
        defw inschr
        defw dellin
        defw inslin
        defw curpos
        defw curadr
        defw curdef

cdeftb: defb 2bh
        defb 60h
        defb 00h
        defb 6bh
        defb 0bh

oset25: defb 0
        page
; HL > scrbot ?  Y->NC

toobig: ld   bc,(scrbot)
        inc  bc
        ld   a,h
        cp   b
        ret  c
        ld   a,l
        cp   c
        ret

; HL < scrtop ?  Y->NC

toolow: ld   bc,(scrtop)
        dec  bc
        ld   a,b
        cp   h
        ret  c
        ld   a,c
        cp   l
        ret

; compute line# in b (1-24)

lineno: ld   de,0050h
        ld   b,0
        or   a
line1:  sbc  hl,de
        inc  b
        ld   a,h
        cp   3bh
        jr   nz,line1
        ret
        page
; Console output

conout: ld   a,(3)
        and  3
        cp   2
        jp   z,list
        cp   1
        ret  nz
        call savstk
        call swtchi
        ld   hl,<retadr: dw grend2>
        push hl
        ld   hl,(cursor)
        push hl
        ld   a,c
        jp   <escjmp: dw chrout>
                               ;a,c    = Character
                               ;(sp)   = Cursor
                               ;(sp-2) = Ret Adr.              
chrout: pop  de                ;de = cursor
        cp   27
        jr   z,grendx
        ld   hl,grend0         ;change if NOT esc
        ex   (sp),hl

grendx: push de                ;(sp) = cursor
        cp   20h
        jr   c,ctrl

; Normal char display

        pop  hl
        ld   a,(invers)
        or   c
        ld   (hl),a
        inc  hl
        ret                    ;to grend0

; common return

grend0: call toobig
        jr   c,grend2
        call scroll

grend2: call swtcho

; Set Cursor Position to CRTC

putcur: ld   bc,-3c00h
        ld   (cursor),hl
        add  hl,bc
        ld   c,0f6h
        ld   a,0eh
        out  (c),a
        inc  c
        out  (c),h
        dec  c
        inc  a
        out  (c),a
        inc  c
        out  (c),l
        ret

ctrl:   add  a,a
        ld   e,a
        ld   d,0
        ld   hl,gtab
        add  hl,de
        ld   a,(hl)
        inc  hl
        ld   h,(hl)
        ld   l,a
        ex   (sp),hl
        ret
                               ; hl = cursor
                               ;(sp)= grend0 if NOT esc
                               ;(sp)= grend2 if esc
        page
back:   dec  hl                ;Backspace does NOT erase
        call toolow
        ret  c
        inc  hl
        ret

cr:     call lineno
cr1:    ld   hl,3bb0h
cr2:    add  hl,de
        djnz cr2
        ret

; Cursor to end of line

cureol: call cr
        ld   de,79
        add  hl,de
        ret

crlf:   call cr

lf:     ld   de,80
        add  hl,de
        ret

tab:    ld   a,20h
        ld   (hl),a
        inc  hl
        call toobig
        jr   c,tab1
        call scroll
tab1:   ld   a,l
        and  7
        jr   nz,tab
        ret

curup:  ld   de,-80
        add  hl,de
        call toolow
        ret  c
        ld   de,80
        add  hl,de
        ret

currgt: inc  hl
        call toobig
        ret  c
        dec  hl
        ret

curdo:  call lf
        call toobig
        ret  c
        sbc  hl,de             ;CY is 0 !
        ret

chome:  ld   hl,(scrtop)
        ret

        page
; a = 27 (esc)
escape: push hl
        ld   hl,escap1
eschng: ld   (escjmp),hl
        pop  hl
        ret

escng1: ld   (escjmp),hl
        ld   hl,grend0
        ld   (retadr),hl
        pop  hl
        ret

; a = xx (after esc !)

escap1: ld   bc,jmptab-esctab
        ld   hl,esctab
        cpir
        jr   nz,escen1
        sla  c
        ld   hl,jmptab
        add  hl,bc
        ld   a,(hl)
        inc  hl
        ld   h,(hl)
        ld   l,a
        jp   (hl)

escend: push hl
escen1: ld   hl,grend2
        ld   (retadr),hl
        ld   hl,chrout
        jr   eschng

curdef: ld   hl,curdf1
        jr   escng1

curadr: ld   hl,curad1
        jr   escng1

line25: ld   hl,linoff
        jr   escng1

scprto: ld   hl,scprt1
        jr   escng1

scprbo: ld   hl,scprb1
        jr   escng1

setatt: ld   hl,attrib
        jr   escng1
        page

; Reverse Linefeed

rvrslf: pop  de                ;de=cursor
        ld   hl,chrout
        ld   (escjmp),hl       ;reset jmp vector
        ex   de,hl             ;hl=cursor
        jp   curup

; Define cursor

curdf1: sub  30h
        jr   c,curdf4
        cp   5
        jr   nc,curdf4
        ld   bc,cdeftb
curdf2: or   a
        jr   z,curdf3
        inc  bc
        dec  a
        jr   curdf2
curdf3: ld   a,0ah
        out  (0f6h),a
        ld   a,(bc)
        out  (0f7h),a
curdf4: jp   escen1

; new row

curad1: ld   (newrow),a
        ld   hl,curad2
        jp   escng1

; new column

curad2: pop  hl
        ld   a,(newrow)
        sub  20h
        cp   24
        jr   c,curad3
        ld   a,0
curad3: ld   l,a
        ld   h,0
        ld   e,l
        ld   d,h
        add  hl,hl
        add  hl,hl
        add  hl,de
        add  hl,hl
        add  hl,hl
        add  hl,hl
        add  hl,hl
        ld   a,c
        sub  20h
        cp   80
        jr   c,curad4
        ld   a,0
curad4: ld   e,a
        ld   d,3ch
        add  hl,de
        jp   escend

; report cursor position
; E = Row, D = Column

curpos: pop  hl
        push hl
        call lineno
        ld   a,b
        call cr1
        ex   de,hl             ;de = Current row
        pop  hl
        or   a
        sbc  hl,de             ;hl = Current column
        add  a,1fh
        ld   e,a
        ld   a,l
        add  a,20h
        ld   d,a
        jp   escend

; Insert line

inslin: pop  hl
        call cr                ;HL=Start of CURRENT line
        ld   (cursor),hl
        ld   de,(scrlst)
        ld   a,h
        cp   d
        jr   nz,not24
        ld   a,l
        cp   e
        jr   nz,not24
        jp   eraeol+1          ;CAUTION !!

not24:  push hl
        ld   de,(scrlst)
        dec  de
        ex   de,hl
        or   a
        sbc  hl,de
        inc  hl
        ld   c,l
        ld   b,h
        ld   hl,(scrlst)
        dec  hl
        ld   de,(scrbot)
        lddr
        pop  hl
        jp   eraeol+1          ;CAUTION !!

; Delete line

dellin: pop  hl
        call cureol
        inc  hl                ;HL=start of NEXT line
        call toobig
        jr   nc,is24           ;its 24th line
        push hl
        ld   de,(scrbot)
        ex   de,hl
        or   a
        sbc  hl,de
        inc  hl
        ld   c,l
        ld   b,h
        pop  hl
        push hl
        ld   de,-80
        add  hl,de
        ld   (cursor),hl
        ex   de,hl
        pop  hl
        ldir
delend: ld   de,(scrlst)
        jp   eraeof+1          ;CAUTION !!

is24:   ld   hl,(scrlst)
        ld   (cursor),hl
        jr   delend

; Insert character

inschr: pop  hl
        push hl
        call cureol
        pop  de
        push hl
        or   a
        sbc  hl,de
        pop  de
        jr   z,nodone
        ld   b,h
        ld   c,l
        ld   h,d
        ld   l,e
        dec  hl
        lddr
        inc  hl
        ld   (hl),20h
        jp   escend

; Delete character

delchr: pop  hl
        push hl
        call cureol
        pop  de
        or   a
        sbc  hl,de
        jr   z,nodone
        ld   b,h
        ld   c,l
        ld   h,d
        ld   l,e
        inc  hl
        ldir
        dec   hl
        ld   (hl),20h

nodone: ld   hl,(cursor)
        jp   escend

; Erase to end of line

eraeol: pop  hl
        push hl
        call cureol
        pop  de
        jr   filspc

; Erase to end of frame

eraeof: pop  de
        ld   hl,(scrbot)
filspc: or   a
        sbc  hl,de
        jr   z,filend
        ld   b,h
        ld   c,l
filsp1: ld   h,d
        ld   l,e
        inc  de
        ld   (hl),20h
        ldir
filend: jp   nodone

; Set Video Attribute
; 0 = Invoff
; 4 = Invon

attrib: cp   '4'
        jr   nz,invoff

; Invert on/off

invon:  ld   a,80h
        jr   invset
invoff: xor  a
invset: ld   (invers),a
        jp   escen1

; Protect toplines

scprt1: cp   13                ;max 12 lines
        jp   nc,escen1
        ld   b,a
        inc  b
        ld   hl,3c00h - 80
        ld   de,80
scprt2: add  hl,de
        djnz scprt2
        ld   (scrtop),hl
        jp   escen1

; Protect bottomlines

scprb1: cp   13                ;max 12 lines
        jp   nc,escen1
        ld   b,a
        inc  b
        ld   hl,4380h
        ld   de,-80
scprb2: add  hl,de
        djnz scprb2
        ld   (scrlst),hl
        ld   de,79
        add  hl,de
        ld   (scrbot),hl
        jp   escen1

; Fill statusline

linoff: cp   80                ;Get offset for 25th line
        jp   nc,escen1
setoff: ld   (oset25),a
linset: ld   hl,lintxt
        jp   escng1

lintxt: cp   03h
        jp   z,escen1
        xor  80h
        ld   c,a
        ld   hl,4380h
        ld   a,(oset25)
        ld   e,a
        ld   d,0
        add  hl,de
        ld   (hl),c
        inc  a
        cp   80
        jr   nc,linset
        jr   setoff

clscrn: pop  hl                ;pop cursor
        call cls
        jp   escend

scroll: push de
        ld   hl,(scrlst)
        push hl
        ld   de,(scrtop)
        or   a
        sbc  hl,de
        ld   c,l
        ld   b,h
        ld   hl,80
        add  hl,de
        ldir
        ld   bc,79

scrclr: pop  hl
        push hl
        ld   e,l
        ld   d,h
        inc  de
        ld   (hl),20h
        ldir
        pop  hl
        pop  de
        ret

cls:    push de
        ld   de,(scrtop)
        push de
        ld   hl,(scrbot)
        or   a
        sbc  hl,de
        ld   c,l
        ld   b,h
        jr   scrclr
        page
; List output

list:   ld   a,(3)
        and  0c0h
        ret  z                 ;tty not installed
        cp   40h
        jp   z,conout
        cp   0c0h
        jr   z,hexlst

; LPT: Lprint char

list1:  call listst
        jr   z,list1
        ld   a,c
        out  (0fdh),a
        ret

; UL1: Lprint hexbyte

hexlst: ld   a,c
        push af
      4:rrca
        call hxlst1
        pop  af
        call hxlst1
        ld   c,20h
        jr   list1

; Lprint hexdigit

hxlst1: and  0fh
        cp   0ah
        jr   c,hxlst2
        add  a,07h
hxlst2: add  a,30h
        ld   c,a
        jr   list1

; List status

listst: in   a,(0fdh)
        and  0f0h
        cp   30h
        ld   a,0
        jr   nz,lists1
        dec  a
lists1: or   a
        ret

        INCLUDE BIOSDSK/MAC

	.dephase
	end
